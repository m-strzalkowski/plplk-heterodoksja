\chapter{Wnioski}%%jeszcze niezbyt dokładnie zredagowane...
Napisanie programu prezentowanego kompilatora zajęło mi około trzech miesięcy wytężonej pracy w lecie 2024 roku. To niewątpliwie mniej niż osiemnaście roboczolat, zadeklarowanych przez twórców pierwszego kompilatora Fortranu\cite{FORTRAN_AUTOMATIC_CODING_SYSTEM}, czy czas spędzony na rozwoju Pascala\cite{Wirth_recollections_Pascal}. Nie jest to wynik zadziwiający, zważywszy na poziom rozwoju wykorzystanych narzędzi.

Zanim jednak ogłoszę możliwość nieskrępowanego praktykowania językotwórstwa eksploracyjnego w dzisiejszych warunkach, powinienem nadmienić, że całkowity koszt takiego projektu należałoby dość znacznie podwyższyć, o ile nie angażuje się w niego programistów posiadających już doświadczenie w tej dziedzinie. W moim wypadku, zdobycie tego doświadczenia oznaczało wpierw wykonanie wspomnianego projektu zaliczeniowego (który okazał się być o wiele bardziej pracochłonny, niż jest to właściwe). W następnych latach wykonałem również w zasadzie cztery aplikacje, wykorzystując pierwotny kod i pomysły i rozwijając umiejętności. Prezentowany tu program, jego architektura jest owocem tych wysiłków i wyciągania wniosków z różnorakich porażek (zwłaszcza związanych z pisaniem własnych maszyn wirtualnych). Proces projektowania języka wymagał dość szerokiej kwerendy, w celu przyswojenia i porównania istniejących rozwiązań, konieczne tez było przyswojenie literatury przedmiotu, w czym szczególnie pomocne okazał się być podręcznik Waite'a i Goos'a\cite{waite_goos} oraz ,,Dragon Book''\cite{DRAGON_BOOK}.

\subsection{Ortodoksja, heterodoksja i herezje}
W niniejszej pracy udało się zaprojektować nowy język wysokiego poziomu i wykonać jego kompilator. Język nie przystaje wprawdzie do stylu pojawiających się ostatnio języków programowania, ani do powszechnych poglądów na temat wykorzystywania języka polskiego w informatyce. Odbiega on jednak od ,,ortodoksji'' w granicach wyznaczonych przez wielkie dokonania lingwistyki formalnej, starsze języki (choć czerpiąc idee również ze współczesności), używając najnowszych narzędzi, mam zatem nadzieję, że nie popada w żadną ,,herezję'' i całe przedsięwzięcie można określić mianem ,,heterodoksyjnego''.

\subsection{Podobne projekty}
Nie jest to wprawdzie wiedza powszechna, sądząc po metrykach odwiedzin i reakcji, zapewnianych przez repozytoria, lecz istnieje obecnie dość dużo projektów o podobnej naturze, wykorzystujących llvm. Jednymi z ciekawszych są Odin\cite{Odin} i jeszcze nie wydany Jai\cite{Jai}, mogące zapewniać miarę potencjalnych prospektów rozwoju (oraz trudności) dla prezentowanego projektu. Niektóre prezentowane w nich idee są niezwykle interesujące - np. ,,compile time execution'' z Jai można rozważać jako jedno z rozwiązań problemu zbytniego uogólniania języków ogólnego przeznaczenia i przesuwania analizy semantycznej do czasu wykonania, opisanej we wprowadzeniu.\ref{czy_potrzebne}

\subsection{Możliwości rozwoju}
W tym wcieleniu projektu, udało się zaimplementować solidną, elastyczną ,,maszynerię'' kompilatora, pozostawiając sam język w dość podstawowej postacii. Powodem powstrzymania się od najciekawszej i najbardziej efektownej działalności językotwórczej była chęć uzyskania wpierw stabilnego systemu, aby zasadnicze błędy techniczne wyeliminować osobno, nie przeplatając ich z rozwojem mechanizmów translacji konstrukcji wysokopoiomowych. ,,Obniżanie'' konstruktów składniowych takich jak np. interfejsy czy ,,opasłe wskaźniki'' (fat pointers) wymaga znacznej ilości kodu (co można zaobserwować w repozytoriach) oraz wysiłku przeznaczonego na doprowadzenie ich do wymaganej niezawodności (co wybrzmiewa w komentarzach praktyków).

Z perspektywy prowadzenia projektu informatycznego, wydaje się być rozsądne, uzyskać wpierw solidny fundament, użytkowac potem system w praktyce, celem zebrania doświadczeń, by dopiero potem przystąpić do następnego etapu. To powieszawszy, już mam przygotowany schemat translacji dla interfejsów, pewne modyfikacje inspirowane Swiftem oraz kilka innych pomysłów, które zamierzam zrealizować przy najbliższej okazji.
%%% do przepisania....

\subsection{Zakończenie}
Obserwując współcześnie rozwijane języki, nie sposób odnieść wrażenia, że żaden z nich nie może się obejść nie tylko bez oryginalnej nazwy, lecz i bez logotypu (często w formie animistycznej). Prezentowany tutaj język, z racji inspiracji wieloma językami z lat 70, których nazwy zaczynały się od PL/, oraz języka stanowiącego substrat leksykalny, otrzymał nazwę PL/PL oraz poniższy logotyp.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{images/znaczek.png}
\end{figure}